Value,Description,Source
John Wick,<p>john wick</p>↵,john wick
Footprinting,"<p>An adversary engages in probing and exploration activities to identify constituents and properties of the target. Footprinting is a general term to describe a variety of information gathering techniques, often used by attackers in preparation for some attack. It consists of using tools to learn as much as possible about the composition, configuration, and security mechanisms of the targeted application, system or network. Information that might be collected during a footprinting effort could include open ports, applications and their versions, network topology, and similar information. While footprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.</p>↵",CAPEC
ICMP Echo Request Ping,"<p>An attacker sends out an ICMP Type 8 Echo Request, commonly known as a &#39;Ping&#39;, in order to determine if a target system is responsive. If the request is not blocked by a firewall or ACL, the target host will respond with an ICMP Type 0 Echo Reply datagram. This type of exchange is usually referred to as a &#39;Ping&#39; due to the Ping utility present in almost all operating systems. Ping, as commonly implemented, allows a user to test for alive hosts, measure round-trip time, and measure the percentage of packet loss. Performing this operation for a range of hosts on the network is known as a &#39;Ping Sweep&#39;. While the Ping utility is useful for small-scale host discovery, it was not designed for rapid or efficient host discovery over large network blocks. Other scanning utilities have been created that make ICMP ping sweeps easier to perform. Most networks filter ingress ICMP Type 8 messages for security reasons. Various other methods of performing ping sweeps have developed as a result. It is important to recognize the key security goal of the attacker is to discover if an IP address is alive, or has a responsive host. To this end, virtually any type of ICMP message, as defined by RFC 792 is useful. An attacker can cycle through various types of ICMP messages to determine if holes exist in the firewall configuration. When ICMP ping sweeps fail to discover hosts, other protocols can be used for the same purpose, such as TCP SYN or ACK segments, UDP datagrams sent to closed ports, etc. The attackers goal is to discover as many potential targets as possible can utilize a wide range of techniques to achieve this end. ICMP pings have the following characteristics:</p>↵",CAPEC
ICMP Address Mask Request,"<p>An attacker sends an ICMP Type 17 Address Mask Request to gather information about a target&#39;s networking configuration. ICMP Address Mask Requests are defined by RFC-950, &quot;Internet Standard Subnetting Procedure.&quot; An Address Mask Request is an ICMP type 17 message that triggers a remote system to respond with a list of its related subnets, as well as its default gateway and broadcast address via an ICMP type 18 Address Mask Reply datagram. Gathering this type of information helps an attacker plan router-based attacks as well as denial-of-service attacks against the broadcast address. Many modern operating systems will not respond to ICMP type 17 messages for security reasons. Determining whether a system or router will respond to an ICMP Address Mask Request helps the attacker determine operating system or firmware version. Additionally, because these types of messages are rare they are easily spotted by intrusion detection systems. Many ICMP scanning tools support IP spoofing to help conceal the origin of the actual request among a storm of similar ICMP messages. It is a common practice for border firewalls and gateways to be configured to block ingress ICMP type 17 and egress ICMP type 18 messages.</p>↵",CAPEC
ICMP Timestamp Request,"<p>An adversary sends an ICMP type 13 Timestamp Request to determine the time as recorded by a remote target. Timestamp Replies, ICMP Type 14, usually return a value in Greenwich Mean Time. An adversary can attempt to use an ICMP Timestamp requests to &#39;ping&#39; a remote system to see if is alive. An adversary may be able to use the timestamp returned from the target to attack time-based security algorithms, such as random number generators, or time-based authentication mechanisms. Additionally, because these types of messages are rare they are easily spotted by intrusion detection systems. Many ICMP scanning tools support IP spoofing to help conceal the origin of the actual request among a storm of similar ICMP messages. It is a common practice for border firewalls and gateways to be configured to block ingress ICMP type 13 and egress ICMP type 14 messages.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The ability to send an ICMP type 13 query (Timestamp Request) to a remote target and receive an ICMP type 14 message (Timestamp Reply) in response.</p>↵⇥</li>↵</ul>↵",CAPEC
ICMP Information Request,"<p>An adversary sends an ICMP Information Request to a host to determine if it will respond to this deprecated mechanism. ICMP Information Requests are a deprecated message type that no has any use. Information Requests were originally used for diskless machines to automatically obtain their network configuration, but this message type has been superseded by more robust protocol implementations like DHCP.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The ability to send an ICMP Type 15 Information Request and receive an ICMP Type 16 Information Reply in response.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP ACK Ping,"<p>An attacker sends a TCP segment with the ACK flag set to a remote host for the purpose of determining if the host is alive. This is one of several TCP &#39;ping&#39; types. The RFC 793 expected behavior for a service is to respond with a RST &#39;reset&#39; packet to any unsolicited ACK segment that is not part of an existing connection. So by sending an ACK segment to a port, an attacker identify that the host is alive by looking for a RST packet. Typically a remote server will respond with a RST regardless of whether a port is open or closed. In either case, the attacker can determine that the host is alive. TCP ACK pings cannot discover the state of a remote port because the behavior is the same in either case. TCP ACK pings are most likely to fail in cases where a stateful firewall is present. The firewall will look up the ACK packet in its state-table and discard the segment because it does not correspond to any active connection. A TCP ACK Ping has the following characteristics:</p>↵↵<ul>↵⇥<li>1. Host Discovery: Can be used to discover if a host is alive via RST response packets sent from the host.</li>↵⇥<li>2. Effective Against: Stateless Firewalls due to a typical lack of rules that reject unsolicited ACK packets.</li>↵⇥<li>3. Weak Against: Stateful Firewalls due to the ability to reject a packet not part of an existing connection.</li>↵⇥<li>4. Port State: Unable to determine if a port is open or closed.</li>↵</ul>↵↵<p>The tool nmap will send TCP ACK pings when the command line &quot;-PA&quot; switch is used. Sending an ACK ping requires the ability to access &quot;raw sockets&quot; in order to create the packets with direct access to the packet header.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The ability to send an ACK packet to a remote host and identify the response. Creating the ACK packet without building a full connection requires the use of raw sockets. As a result, it is not possible to send a TCP ACK ping from some systems (Windows XP SP 2) without the use of third-party packet drivers like Winpcap. On other systems (BSD, Linux) administrative privileges are required in order to write to the raw socket.</p>↵⇥</li>↵</ul>↵",CAPEC
UDP Ping,"<p>An attacker sends a UDP datagram to the remote host to determine if the host is alive. If a UDP datagram is sent to an open UDP port there is very often no response, so a typical strategy for using a UDP ping is to send the datagram to a random high port on the target. The goal is to solicit an ICMP port unreachable message from the target, indicating that the host is alive. UDP pings are useful because some firewalls are not configured to block UDP datagrams sent to strange or typically unused &#39; ports, like ports in the 65K range. Additionally, while some firewalls may filter incoming ICMP, weaknesses in firewall rule-sets may allow certain types of ICMP (host unreachable, port unreachable) which are useful for UDP ping attempts. A UDP Ping has the following characteristics:</p>↵↵<ul>↵⇥<li>1. Host Discovery: Can be used to discover if a host is alive via ICMP Port Unreachable Messages.</li>↵⇥<li>2. Effective Against: Firewalls that allow some incoming UDP which are not configured to block egress ICMP messages.</li>↵⇥<li>3. Weak Against: Firewalls properly configured to block UDP datagrams that are also block egress ICMP messages.</li>↵⇥<li>4. Port State: Able to determine if a port is closed via ICMP Port Unreachable Messages.</li>↵</ul>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The ability to send a UDP datagram to a remote host and receive a response.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP SYN Ping,"<p>An attacker uses a TCP SYN packets as a means of purpose of host discovery. Typical RFC 793 behavior specifies that when a TCP port is open, a host must respond to an incoming SYN &quot;synchronize&quot; packet by completing stage two of the &#39;three-way handshake&#39; by sending an SYN/ACK in response. When a port is closed, RFC 793 behavior is to respond with a RST &quot;reset&quot; packet. This behavior can be used to &#39;ping&#39; a target to see if it is alive by sending a TCP SYN packet to a port and then looking for a RST or an ACK packet in response. Due to the different responses from open and closed ports, SYN packets can be used to determine the remote state of the port. A TCP SYN ping is also useful for discovering alive hosts protected by a stateful firewall. In cases where a specific firewall rule does not block access to a port, a SYN packet can pass through the firewall to the host and solicit a response from either an open or closed port. When a stateful firewall is present SYN pings are preferable to ACK pings, because a stateful firewall will typically drop all unsolicited ACK packets because they are not part of an existing or new connection. TCP SYN pings often fail when a stateless ACL or firewall is configured to blanket-filter incoming packets to a port. The firewall device will discard any SYN packets to a blocked port. An attacker will often alternate between SYN and ACK pings to discover if a host is alive. A TCP SYN ping has the following characteristics:</p>↵↵<ul>↵⇥<li>1. Host Discovery: Can be used to discover if a host is alive via ACK or RST packets.</li>↵⇥<li>2. Effective Against: Stateful Firewalls that allow incoming new connections to target ports.</li>↵⇥<li>3. Weak Against: Stateless firewalls that blanket-filter incoming SYN</li>↵⇥<li>4. Port State: Able to determine port state via SYN/ACK or RST response.</li>↵</ul>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The ability to send a TCP SYN packet to a remote target. Depending upon the operating system, the ability to craft SYN packets may require elevated privileges.</p>↵⇥</li>↵</ul>↵",CAPEC
WiFi MAC Address Tracking,"<p>In this attack scenario, the attacker passively listens for WiFi messages and logs the associated Media Access Control (MAC) addresses. These addresses are intended to be unique to each wireless device (although they can be configured and changed by software). Once the attacker is able to associate a MAC address with a particular user or set of users (for example, when attending a public event), the attacker can then scan for that MAC address to track that user in the future.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>None</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations<br />↵Automatic randomization of WiFi MAC addresses<br />↵Frequent changing of handset and retransmission device</p>↵",CAPEC
WiFi SSID Tracking,"<p>In this attack scenario, the attacker passively listens for WiFi management frame messages containing the Service Set Identifier (SSID) for the WiFi network. These messages are frequently transmitted by WiFi access points (e.g., the retransmission device) as well as by clients that are accessing the network (e.g., the handset/mobile device). Once the attacker is able to associate an SSID with a particular user or set of users (for example, when attending a public event), the attacker can then scan for this SSID to track that user in the future.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>None</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Do not enable the feature of &quot;Hidden SSIDs&rdquo; (also known as &ldquo;Network Cloaking&rdquo;) &ndash; this option disables the usual broadcasting of the SSID by the access point, but forces the mobile handset to send requests on all supported radio channels which contains the SSID. The result is that tracking of the mobile device becomes easier since it is transmitting the SSID more frequently.<br />↵Frequently change the SSID to new and unrelated values</p>↵",CAPEC
Cellular Broadcast Message Request,"<p>In this attack scenario, the attacker uses knowledge of the target&rsquo;s mobile phone number (i.e., the number associated with the SIM used in the retransmission device) to cause the cellular network to send broadcast messages to alert the mobile device. Since the network knows which cell tower the target&rsquo;s mobile device is attached to, the broadcast messages are only sent in the Location Area Code (LAC) where the target is currently located. By triggering the cellular broadcast message and then listening for the presence of absence of that message, an attacker could verify that the target is in (or not in) a given location.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The attacker must have knowledge of the target&rsquo;s mobile phone number.</p>↵⇥</li>↵</ul>↵",CAPEC
Signal Strength Tracking,"<p>In this attack scenario, the attacker passively monitors the signal strength of the target&rsquo;s cellular RF signal or WiFi RF signal and uses the strength of the signal (with directional antennas and/or from multiple listening points at once) to identify the source location of the signal. Obtaining the signal of the target can be accomplished through multiple techniques such as through Cellular Broadcast Message Request or through the use of IMSI Tracking or WiFi MAC Address Tracking.</p>↵",CAPEC
TCP SYN Scan,"<p>An attacker uses a SYN scan to determine the status of ports on the remote target. SYN scanning is the most common type of port scanning that is used because of its enormous advantages and few drawbacks. As a result, novice attackers tend to overly rely on the SYN scan while performing system reconnaissance. As a scanning method the primary advantages of SYN scanning are its universality and speed. RFC 793 defines the required behavior of any TCP/IP device in that an incoming connection request begins with a SYN packet, which in turn must be followed by a SYN/ACK packet from the receiving service. For this reason, like TCP Connect scanning, SYN scanning works against any TCP stack. Unlike TCP Connect scanning, it is possible to scan thousands of ports per second using this method. This type of scanning is usually referred to as &#39;half-open&#39; scanning because it does not complete the three-way handshake. The scanning rate is extremely fast because no time is wasted completing the handshake or tearing down the connection. TCP SYN scanning can also immediately detect 3 of the 4 important types of port status: open, closed, and filtered. When a SYN is sent to an open port and unfiltered port, a SYN/ACK will be generated. This technique allows an attacker to scan through stateful firewalls due to the common configuration that TCP SYN segments for a new connection will be allowed for almost any port. When a SYN packet is sent to a closed port a RST is generated, indicating the port is closed. When SYN scanning to a particular port generates no response, or when the request triggers ICMP Type 3 unreachable errors, the port is filtered. A TCP Connect scan has the following characteristics:</p>↵↵<ul>↵⇥<li>1. Speed: TCP SYN scanning is fast compared to other types of scans.</li>↵⇥<li>2. Stealth: TCP SYN scanning is stealthy and SYN scan detection is fraught with false positives.</li>↵⇥<li>3. Open Port: Detects that a port is open via a successful SYN/ACK to the SYN.</li>↵⇥<li>4. Closed Port: Detects that a port is closed via a successful RST to the SYN</li>↵⇥<li>5. Filtered Port: No response, or ICMP messages, indicates the presence of a filter.</li>↵⇥<li>6. Unfiltered Port: Cannot distinguish between a state-fully filtered port and an unfiltered port.</li>↵</ul>↵↵<p>SYN scanning is fast and provides the attacker with a wealth of information. The primary drawback is that SYN scanning requires the ability to access &quot;raw sockets&quot; in order to create the packets. As a result, it is not possible to perform a SYN scan from some systems (Windows XP SP 2). On other systems (BSD, Linux) administrative privileges are required in order to write to the raw socket.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>This scan type is not possible with some operating systems (Windows XP SP 2). On Linux and Unix systems it requires root privileges to use raw sockets.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP Connect Scan,"<p>An attacker uses full TCP connection attempts to determine if a port is open. The scanning process involves completing a &#39;three-way handshake&#39; with a remote port, and reports the port as closed if the full handshake cannot be established. An advantage of TCP connect scanning is that it works against any TCP/IP stack. RFC 793 defines how TCP connections are established and torn down. TCP connect scanning commonly involves establishing a full connection, and then subsequently tearing it down, and therefore involves sending a significant number of packets to each port that is scanned. This type of scanning has the following characteristics. Compared to other types of scans, a TCP Connect scan is slow and methodical. This type of scanning causes considerable noise in system logs and can be spotted by IDS/IPS systems. In terms of port status, TCP Connect scanning can detect when a port is open by completing the three-way handshake, but it cannot distinguish a port that is unfiltered with no service running on it from a port that is filtered by a firewall but contains an active service. Due to the significant volume of packets exchanged per port, TCP connect scanning can become very time consuming. Generally, it is not used as a method for performing a comprehensive port scan, but is reserved for checking a short list of common ports. A TCP Connect scan has the following characteristics:</p>↵↵<ul>↵⇥<li>1. Speed: TCP Connect scanning is very slow.</li>↵⇥<li>2. Stealth: TCP SYN scanning is extremely noisy and involves a significant number of packets.</li>↵⇥<li>3. Open Port: Detects that a port is open via a successful three-way handshake</li>↵⇥<li>4. Filtered Port: Cannot distinguish a closed (unfiltered) port from an open (filtered) port.</li>↵⇥<li>5 .Unfiltered Port: Can detect an unfiltered port only when the unfiltered port is in front of an active TCP/IP service.</li>↵</ul>↵↵<p>The TCP Connect scan has the advantage of versatility and ease of use in that it works equally well against all TCP stacks and that it is easy for a novice to interpret the results of the scan due to its all or nothing nature. Its disadvantages are noise, speed, and poor visibility into the filter structure of a firewall. As a general rule, performing a full TCP connect scan against a host can take multiple days.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The TCP connect requires the ability to connect to an available port and complete a &#39;three-way-handshake&#39; This scanning technique does not require any special privileges in order to perform. This type of scan works against all TCP/IP stack implementations.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP FIN scan,"<p>An attacker uses a TCP FIN scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the FIN bit set in the packet header. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. The major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to &#39;build&#39; a connection. FIN packets, like out-of-state ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason FIN scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports.</p>↵↵<ul>↵⇥<li>1. Speed: TCP FIN scanning is fast compared to other types of scans</li>↵⇥<li>2. Stealth: TCP FIN scanning is stealthy compared to other types of scans</li>↵⇥<li>3. Open Port: Detects an open port via no response to the segment</li>↵⇥<li>4. Closed Port: Detects that a closed via a RST received in response to the FIN</li>↵⇥<li>5. Filtered Port: Cannot distinguish between a filtered port and an open port</li>↵⇥<li>6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port</li>↵</ul>↵↵<p>FIN scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, FIN scanning a system protected by a stateful firewall may indicate all ports being open. For these reasons, FIN scanning results must always be interpreted as part of a larger scanning strategy. FIN scanning is still relatively stealthy as the packets tend to blend in with the background noise on a network link. FIN scans are detected via heuristic (non-signature) based algorithms, much in the same way as other scan types are detected.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>FIN scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP Xmas Scan,"<p>An attacker uses a TCP XMAS scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the all flags sent in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. he major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to &#39;build&#39; a connection. XMAS packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason FIN scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports.</p>↵↵<ul>↵⇥<li>1. Speed: TCP XMAS scanning is fast compared to other types of scans</li>↵⇥<li>2. Stealth: TCP XMAS scanning was once stealthy, but is now easily detected by IDS/IPS systems</li>↵⇥<li>3. Open Port: Detects an open port via no response to the segment</li>↵⇥<li>4. Closed Port: Detects that a closed via a RST received in response to the FIN</li>↵⇥<li>5. Filtered Port: Cannot distinguish between a filtered port and an open port</li>↵⇥<li>6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port</li>↵</ul>↵↵<p>XMAS scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, XMAS scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, XMAS scans are flagged by almost all intrusion prevention or intrusion detection systems.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>XMAS scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP Null Scan,"<p>An attacker uses a TCP NULL scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with no flags in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. he major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to &#39;build&#39; a connection. NULL packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason NULL scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports.</p>↵↵<ul>↵⇥<li>1. Speed: TCP NULL scanning is fast compared to other types of scans</li>↵⇥<li>2. Stealth: TCP NULL scanning was once stealthy, but is now easily detected by IDS/IPS systems</li>↵⇥<li>3. Open Port: Detects an open port via no response to the segment</li>↵⇥<li>4. Closed Port: Detects that a closed via a RST received in response to the FIN</li>↵⇥<li>5. Filtered Port: Cannot distinguish between a filtered port and an open port</li>↵⇥<li>6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port</li>↵</ul>↵↵<p>NULL scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, NULL scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, NULL scans are flagged by almost all intrusion prevention or intrusion detection systems.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>NULL scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP ACK Scan,"<p>An attacker uses TCP ACK segments to gather information about firewall or ACL configuration. The purpose of this type of scan is to discover information about filter configurations rather than port state. This type of scanning is rarely useful alone, but when combined with SYN scanning, gives a more complete picture of the type of firewall rules that are present. When a TCP ACK segment is sent to a closed port, or sent out-of-sync to a listening port, the RFC 793 expected behavior is for the device to respond with a RST. Getting RSTs back in response to a ACK scan gives the attacker useful information that can be used to infer the type of firewall present. Stateful firewalls will discard out-of-sync ACK packets, leading to no response. When this occurs the port is marked as filtered. When RSTs are received in response, the ports are marked as unfiltered, as the ACK packets solicited the expected behavior from a port. When combined with SYN techniques an attacker can gain a more complete picture of which types of packets get through to a host and thereby map out its firewall rule-set. ACK scanning, when combined with SYN scanning, also allows the attacker analyze whether a firewall is stateful or non-stateful. If a SYN solicits a SYN/ACK or a RST and an ACK solicits a RST, the port is unfiltered by any firewall type. If a SYN solicits a SYN/ACK, but an ACK generates no response, the port is statefully filtered. When a SYN generates neither a SYN/ACK or a RST, but an ACK generates a RST, the port is statefully filtered. When neither SYN nor ACK generates any response, the port is blocked by a specific firewall rule, which can occur via any type of firewall.</p>↵↵<ul>↵⇥<li>1. Speed: TCP ACK scanning is fast compared to other types of scans</li>↵⇥<li>2. Stealth: TCP ACK scanning is stealthy</li>↵⇥<li>3. Open Port: Cannot detect open ports</li>↵⇥<li>4. Closed Port: Cannot detect closed ports</li>↵⇥<li>5. Filtered Port: Can detect stateful vs. non-stateful filters when combined with SYN probes</li>↵⇥<li>6. Unfiltered Port: Can detect unfiltered ports when combined with SYN probes</li>↵</ul>↵↵<p>Interpreting the results of ACK scanning requires rather sophisticated analysis. A skilled attacker may use this method to map out firewall rules, but the results of ACK scanning will be less useful to a novice.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>ACK scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP Window Scan,"<p>An attacker engages in TCP Window scanning to analyze port status and operating system type. TCP Window scanning uses the ACK scanning method but examine the TCP Window Size field of response RST packets to make certain inferences. This scanning method works against fewer TCP stack implementations than any other type of scan. Some operating systems return a positive TCP window size when a RST packet is sent from an open port, and a negative value when the RST originates from a closed port.</p>↵↵<ul>↵⇥<li>1. Speed: TCP Window scanning is fast compared to other types of scans</li>↵⇥<li>2. Stealth: TCP Window scanning is relatively stealthy, much like ACK scanning</li>↵⇥<li>3. Open Port: Can detect open ports based on Window size for a limited number of operating systems</li>↵⇥<li>4. Closed Port: Can detect closed ports based on Window size for limited number of operating systems</li>↵⇥<li>5. Filtered Port: Can identify filtered ports when combined with other methods</li>↵⇥<li>6. Unfiltered Port: Can identify unfiltered ports when combined with other methods</li>↵</ul>↵↵<p>TCP Window scanning is one of the most complex scan types, and its results are difficult to interpret. Window scanning alone rarely yields useful information, but when combined with other types of scanning is more useful. TCP Window scanning is a more reliable means of making inference about operating system versions than port status.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>TCP Window scanning requires the use of raw sockets, and thus cannot be performed from some Windows systems (Windows XP SP 2, for example). On Unix and Linux, raw socket manipulations require root privileges.</p>↵⇥</li>↵</ul>↵",CAPEC
TCP RPC Scan,"<p>An attacker scan for RPC services listing on a Unix/Linux host. This type of scan can be obtained via native operating system utilities or via port scanners like nmap. When performed by a scanner, an RPC datagram is sent to a list of UDP ports and the response is recorded. Particular types of responses can be indicative of well-known RPC services running on a UDP port.</p>↵↵<ul>↵⇥<li>1. Speed: Direct RPC scans that bypass portmapper/sunrpc are typically slow compare to other scan types</li>↵⇥<li>2. Stealth: RPC scanning is not stealthy, as IPS/IDS systems detect RPC queries</li>↵⇥<li>3. Open Port: Can only detect open ports when an RPC service responds</li>↵⇥<li>4. Closed Port: Detects closed ports on the basis of ICMP diagnostic messages.</li>↵⇥<li>5. Filtered Port: Cannot identify filtered ports</li>↵⇥<li>6. Unfiltered Port: Cannot identify unfiltered ports</li>↵</ul>↵↵<p>There are two general approaches to RPC scanning. One is to use a native operating system utility, or script, to query the portmapper/rpcbind application running on port 111. Portmapper will return a list of registered RPC services. Alternately, one can use a port scanner or script to scan for RPC services directly. Discovering RPC services gives the attacker potential targets to attack, as some RPC services are insecure by default.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>RPC scanning requires no special privileges when it is performed via a native system utility.</p>↵⇥</li>↵</ul>↵",CAPEC
UDP Scan,"<p>An attacker engages in UDP scanning to gather information about UDP port status. UDP scanning methods involve sending a UDP datagram to the target port and looking for evidence that the port is closed. Open UDP ports usually do not respond to UDP datagrams as there is no stateful mechanism within the protocol that requires building or establishing a session. Responses to UDP datagrams are therefore application specific and cannot be relied upon as a method of detecting an open port. UDP scanning relies heavily upon ICMP diagnostic messages in order to determine the status of a remote port. Firewalls or ACLs which block egress ICMP error types effectively prevent UDP scans from returning any useful information. UDP scanning is further complicated by rate limiting mechanisms governing ICMP error messages. During a UDP scan, a datagram is sent to a target port. If an ICMP Type 3 Port unreachable error message is returned then the port is considered closed. Different types of ICMP messages can indicate a filtered port.</p>↵↵<ul>↵⇥<li>1. Speed: UDP scanning is very slow due to ICMP rate limiting</li>↵⇥<li>2. Stealth: RPC scanning is relatively stealthy provided the sending rate does not trigger IPS/IDS sensors</li>↵⇥<li>3. Open Port: Infers an open port based on no response, or an occasional response by a well-known service</li>↵⇥<li>4. Closed Port: Detects a closed port using return ICMP diagnostic messages from the host</li>↵⇥<li>5. Filtered Port: Can detect some filtered ports via ICMP diagnostic messages</li>↵⇥<li>6. Unfiltered Port: Can detect unfiltered ports based on some ICMP diagnostic messages</li>↵</ul>↵↵<p>The protocol characteristics of UDP make port scanning inherently more difficult than with TCP, as well as dependent upon ICMP for accurate scanning. Due to ambiguities that can arise between open ports and filtered ports, UDP scanning results often require a high degree of interpretation and further testing to refine. In general, UDP scanning results are less reliable or accurate than TCP-based scanning.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The ability to send UDP datagrams to a host and receive ICMP error messages from that host. In cases where particular types of ICMP messaging is disallowed, the reliability of UDP scanning drops off sharply.</p>↵⇥</li>↵</ul>↵",super@threatq.com
Enumerate Mail Exchange (MX) Records,<p>An attacker enumerates the MX records for a given via a DNS query. This type of information gathering returns the names of mail servers on the network. Mail servers are often not exposed to the Internet but are located within the DMZ of a network protected by a Firewall. A side effect of this configuration is that enumerating the MX records for an organization my reveal the IP address of the firewall or possibly other internal systems. Attackers often resort to MX record enumeration when a DNS Zone Transfer is not possible.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Access to a DNS server that will return the MX records for a network.</p>↵⇥</li>↵</ul>↵,CAPEC
DNS Zone Transfers,"<p>An attacker exploits a DNS misconfiguration that permits a ZONE transfer. Some external DNS servers will return a list of IP address and valid hostnames. Under certain conditions, it may even be possible to obtain Zone data about the organization&#39;s internal network. When successful the attacker learns valuable information about the topology of the target organization, including information about particular servers, their role within the IT structure, and possibly information about the operating systems running upon the network. This is configuration dependent behavior so it may also be required to search out multiple DNS servers while attempting to find one with ZONE transfers allowed.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Access to a DNS server that allows Zone transfers.</p>↵⇥</li>↵</ul>↵",CAPEC
Traceroute Route Enumeration,"<p>An attacker uses a traceroute utility to map out the route which data flows through the network in route to a target destination. Tracerouting can allow an attacker to construct a working topology of systems and routers by listing the systems through which data passes through on their way to the targeted machine. This attack can return varied results depending upon the type of traceroute that is performed. Traceroute works by sending packets to a target while incrementing the Time-to-Live field in the packet header. As the packet traverses each hop along its way to the destination, its TTL expires generating an ICMP diagnostic message that identifies where the packet expired. Traditional techniques for tracerouting involved the use of ICMP and UDP. As more firewalls began to filter ingress ICMP, methods of traceroute using TCP were developed</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>A network capable of routing the attackers&#39; packets to the destination network.</p>↵⇥</li>↵</ul>↵",CAPEC
Detect Unpublicized Web Pages,"<p>An attacker searches a targeted web site for web pages that have not been publicized. Generally this involves mapping the published web site by spidering through all the published links and then attempt to access well-known debugging or logging pages, or otherwise predictable pages within the site tree. For example, if an attacker might be able to notice a pattern in the naming of documents and extrapolate this pattern to discover additional documents that have been created but are no longer externally linked. Using this, the attacker may be able to gain access to information that the targeted site did not intend to make public.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The targeted web site must include pages within its published tree that are not connected to its tree of links. The sensitivity of the content of these pages determines the severity of this attack.</p>↵⇥</li>↵</ul>↵",CAPEC
Detect Unpublicized Web Services,"<p>An attacker searches a targeted web site for web services that have not been publicized. Generally this involves mapping the published web site by spidering through all the published links and then attempt to access well-known debugging or logging services, or otherwise predictable services within the site tree. This attack can be especially dangerous since unpublished but available services may not have adequate security controls placed upon them given that an administrator may believe they are unreachable.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The targeted web site must include unpublished services within its web tree. The nature of these services determines the severity of this attack.</p>↵⇥</li>↵</ul>↵",CAPEC
Screen Temporary Files for Sensitive Information,"<p>An adversary exploits the temporary, insecure storage of information by monitoring the content of files used to store temp data during an application&#39;s routine execution flow. Many applications use temporary files to accelerate processing or to provide records of state across multiple executions of the application. Sometimes, however, these temporary files may end up storing sensitive information. By screening an application&#39;s temporary files, an adversary might be able to discover such sensitive information. For example, web browsers often cache content to accelerate subsequent lookups. If the content contains sensitive information then the adversary could recover this from the web cache.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The target application must utilize temporary files and must fail to adequately secure them against other parties reading them.</p>↵⇥</li>↵</ul>↵",CAPEC
Accessing/Intercepting/Modifying HTTP Cookies,"<p>This attack relies on the use of HTTP Cookies to store credentials, state information and other critical data on client systems. There are several different forms of this attack. The first form of this attack involves accessing HTTP Cookies to mine for potentially sensitive data contained therein. The second form involves intercepting this data as it is transmitted from client to server. This intercepted information is then used by the adversary to impersonate the remote user/session. The third form is when the cookie&#39;s content is modified by the adversary before it is sent back to the server. Here the adversary seeks to convince the target server to operate on this falsified information.</p>↵↵<p>&nbsp;Attack Steps</p>↵↵<p>Explore</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Obtain copy of cookie</strong>: The adversary first needs to obtain a copy of the cookie. The adversary may be a legitimate end user wanting to escalate privilege, or could be somebody sniffing on a network to get a copy of HTTP cookies.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Obtain cookie from local filesystem (e.g. C:\Documents and Settings\*\Cookies and C:\Documents and Settings\*\Application Data\Mozilla\Firefox\Profiles\*\cookies.txt in Windows)</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Sniff cookie using a network sniffer such as Wireshark</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Obtain cookie from local memory or filesystem using a utility such as the Firefox Cookie Manager or AnEC Cookie Editor.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Steal cookie via a cross-site scripting attack.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Guess cookie contents if it contains predictable information.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>Experiment</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Obtain sensitive information from cookie</strong>: The adversary may be able to get sensitive information from the cookie. The web application developers may have assumed that cookies are not accessible by end users, and thus, may have put potentially sensitive information in them.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>If cookie shows any signs of being encoded using a standard scheme such as base64, decode it.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Analyze the cookie&#39;s contents to determine whether it contains any sensitive information.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵⇥<li>↵⇥<p><strong>Modify cookie to subvert security controls.</strong>: The adversary may be able to modify or replace cookies to bypass security controls in the application.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Modify logical parts of cookie and send it back to server to observe the effects.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Modify numeric parts of cookie arithmetically and send it back to server to observe the effects.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Modify cookie bitwise and send it back to server to observe the effects.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Replace cookie with an older legitimate cookie and send it back to server to observe the effects. This technique would be helpful in cases where the cookie contains a &quot;points balance&quot; for a given user where the points have some value. The user may spend his points and then replace his cookie with an older one to restore his balance.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Target server software must be a HTTP daemon that relies on cookies.</p>↵⇥</li>↵⇥<li>↵⇥<p>The cookies must contain sensitive information.</p>↵⇥</li>↵⇥<li>↵⇥<p>The adversary must be able to make HTTP requests to the server, and the cookie must be contained in the reply.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Design: Use input validation for cookies</p>↵↵<p>Design: Generate and validate MAC for cookies</p>↵↵<p>Implementation: Use SSL/TLS to protect cookie in transit</p>↵↵<p>Implementation: Ensure the web server implements all relevant security patches, many exploitable buffer overflows are fixed in patches issued for the software.</p>↵",CAPEC
Directory Indexing,"<p>An adversary crafts a request to a target that results in the target listing/indexing the content of a directory as output. One common method of triggering directory contents as output is to construct a request containing a path that terminates in a directory name rather than a file name since many applications are configured to provide a list of the directory&#39;s contents when such a request is received. An adversary can use this to explore the directory tree on a target as well as learn the names of files. This can often end up revealing test files, backup files, temporary files, hidden files, configuration files, user accounts, script contents, as well as naming conventions, all of which can be used by an attacker to mount additional attacks.</p>↵↵<p>&nbsp;Attack Steps</p>↵↵<p>Explore</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Directory Discovery</strong>: Use a method, either manual, scripted, or automated to discover the directories on the server by making requests for directories that may possibly exist. During this phase the adversary is less concerned with whether a directory can be accessed or indexed and more focused on simply discovering what directories do exist on the target.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Send requests to the web server for common directory names</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>If directories are discovered that are native to a server type further refine the directory search to include directories usually present on those types of servers.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Search for uncommon or potentially user created directories that may be present.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>Experiment</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Iteratively explore directory/file structures</strong>: The adversary attempts to access the discovered directories that allow access and may attempt to bypass server or application level ACLs by using manual or automated methods</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Use a scanner tool to dynamically add directories/files to include their scan based upon data obtained in initial probes.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Use a browser to manually explore the website by issuing a request ending the URL in a slash &#39;/&#39;.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Attempt to bypass ACLs on directories by using methods that known to work against some server types by appending data to the directory request. For instance, appending a Null byte to the end of the request which may cause an ACL to fail and allow access.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Sequentially request a list of common base files to each directory discovered.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Try multiple fuzzing techniques to list directory contents for directories that will not reveal their contents with a &quot;/&quot; request</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>Exploit</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Read directories or files which are not intended for public viewing.</strong>: The adversary attempts to access the discovered directories that allow access and may attempt to bypass server or application level ACLs by using manual or automated methods</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Try multiple exploit techniques to list directory contents for directories that will not reveal their contents with a &quot;/&quot; request</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Try other known exploits to elevate privileges sufficient to bypass protected directories.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>List the files in the directory by issuing a request with the URL ending in a &quot;/&quot; slash.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Access the files via direct URL and capture contents.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Attempt to bypass ACLs on directories by using methods that are known to work against some server types by appending data to the directory request. For instance, appending a Null byte to the end of the request which may cause an ACL to fail and allow access.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Sequentially request a list of common base files to each directory discovered.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵",CAPEC
"Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping","<p>An attacker sends random, malformed, or otherwise unexpected messages to a target application and observes any stack traces produced by error messages. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target&#39;s response. The attacker does not initially know how a target will respond to individual messages but by attempting a large number of message variants they may find a variant that trigger&#39;s desired behavior. In this attack, the purpose of the fuzzing is to cause the targeted application to return an error including a stack trace, although fuzzing a target can also sometimes cause the target to enter an unstable state, causing a crash. The stack trace enumerates the chain of methods that led up to the point where the error was encountered. This can not only reveal the names of the methods (some of which may have known weaknesses) but possibly also the location of class files and libraries as well as parameter values. In some cases, the stack trace might even disclose sensitive configuration or user information.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The target application must fail to sanitize incoming messages adequately before processing and must generate a stack trace in at least some error situations.</p>↵⇥</li>↵</ul>↵",CAPEC
Fuzzing and observing application log data/errors for application mapping,"<p>An attacker sends random, malformed, or otherwise unexpected messages to a target application and observes the application&#39;s log or error messages returned. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target&#39;s response. The attacker does not initially know how a target will respond to individual messages but by attempting a large number of message variants they may find a variant that trigger&#39;s desired behavior. In this attack, the purpose of the fuzzing is to observe the application&#39;s log and error messages, although fuzzing a target can also sometimes cause the target to enter an unstable state, causing a crash. By observing logs and error messages, the attacker can learn details about the configuration of the target application and might be able to cause the target to disclose sensitive information.</p>↵↵<p>&nbsp;Attack Steps</p>↵↵<p>Explore</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Probing</strong>: The attacker uses fuzzing tools to send random malformed messages to web server and observes for server&#39;s log or error message.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>The attacker uses fuzzing tools to send random malformed messages to web server and observes for server&#39;s log or error message.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>Experiment</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Modify the parameters to get the desired information from the error messages.</strong>: Attacker usually needs to modify the fuzzing parameters according to the observed error messages to get the desired sensitive information for the application. To defeat correlation, the attacker may try changing the origin IP addresses or client browser identification strings or start a new session from where he left off in obfuscating the attack.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Modify the parameters in the fuzzing tool according to the observed error messages. Repeat with enough parameters until the application has been sufficiently mapped.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>If the application rejects the large amount of fuzzing messages from the same host machine, the attacker needs to hide the attacks by changing the IP addresses or other credentials.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The target application must fail to sanitize incoming messages adequately before processing.</p>↵⇥</li>↵</ul>↵",CAPEC
Fuzzing for garnering other adjacent user/sensitive data,"<p>An attacker who is authorized to send queries to a target sends variants of expected queries in the hope that these modified queries might return information (directly or indirectly through error logs) beyond what the expected set of queries should provide. Many client applications use specific query templates when interacting with a server and often automatically fill in specific fields or attributes. For example, a client that queries an employee database might have templates such that the user only supplies the target&#39;s name and the template dictates the fields to be returned (location, position in the company, phone number, etc.). If the server does not verify that the query matches one of the expected templates, an attacker who is allowed to send normal queries could modify their query to try to return additional information. In the above example, additional information might include social security numbers or salaries. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target&#39;s response. In this particular attack, the fuzzing is applied to the format of the expected templates, creating variants that request additional information, exclude limiting clauses, or alter fields that identify the requester in order to subvert access controls. The attacker may not know the names of fields to request or how other modifications will affect the server response, but by attempting multiple plausible variants, they might eventually trigger a server response that divulges sensitive information. Other possible outcomes include server crashes and resource consumption if the unexpected queries cause the server to enter an unstable state or perform excessive computation.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The server must assume that the queries it receives follow specific templates and/or have fields or attributes that follow specific procedures. The server must process queries that it receives without adequately checking or sanitizing queries to ensure they follow these templates.</p>↵⇥</li>↵</ul>↵",CAPEC
Cross-Domain Search Timing,"<p>An attacker initiates cross domain HTTP / GET requests and times the server responses. The timing of these responses may leak important information on what is happening on the server. Browser&#39;s same origin policy prevents the attacker from directly reading the server responses (in the absence of any other weaknesses), but does not prevent the attacker from timing the responses to requests that the attacker issued cross domain.</p>↵↵<p>For GET requests an attacker could for instance leverage the &quot;img&quot; tag in conjunction with &quot;onload() / onerror()&quot; javascript events. For the POST requests, an attacker could leverage the &quot;iframe&quot; element and leverage the &quot;onload()&quot; event. There is nothing in the current browser security model that prevents an attacker to use these methods to time responses to the attackers&#39; cross domain requests.</p>↵↵<p>The timing for these responses leaks information. For instance, if a victim has an active session with their online e-mail account, an attacker could issue search requests in the victim&#39;s mailbox. While the attacker is not able to view the responses, based on the timings of the responses, the attacker could ask yes / no questions as to the content of victim&#39;s e-mails, who the victim e-mailed, when, etc. This is but one example; There are other scenarios where an attacker could infer potentially sensitive information from cross domain requests by timing the responses while asking the right questions that leak information.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Ability to issue GET / POST requests cross domain</p>↵↵⇥<p>Java Script is enabled in the victim&#39;s browser</p>↵↵⇥<p>The victim has an active session with the site from which the attacker would like to receive information</p>↵↵⇥<p>The victim&#39;s site does not protect search functionality with cross site request forgery (CSRF) protection</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Design: The victim&#39;s site could protect all potentially sensitive functionality (e.g. search functions) with cross site request forgery (CSRF) protection and not perform any work on behalf of forged requests</p>↵↵<p>Design: The browser&#39;s security model could be fixed to not leak timing information for cross domain requests</p>↵",CAPEC
WSDL Scanning,"<p>This attack targets the WSDL interface made available by a web service. The attacker may scan the WSDL interface to reveal sensitive information about invocation patterns, underlying technology implementations and associated vulnerabilities. This type of probing is carried out to perform more serious attacks (e.g. parameter tampering, malicious content injection, command injection, etc.). WSDL files provide detailed information about the services ports and bindings available to consumers. For instance, the attacker can submit special characters or malicious content to the Web service and can cause a denial of service condition or illegal access to database records. In addition, the attacker may try to guess other private methods by using the information provided in the WSDL files.</p>↵↵<p>&nbsp;Attack Steps</p>↵↵<p>Explore</p>↵↵<ol>↵⇥<li>↵⇥<p>The first step is exploratory meaning the attacker scans for WSDL documents. The WDSL document written in XML is like a handbook on how to communicate with the web services provided by the target host. It provides an open view of the application (function details, purpose, functional break down, entry points, message types, etc.). This is very useful information for the attacker.</p>↵⇥</li>↵</ol>↵↵<p>Experiment</p>↵↵<ol>↵⇥<li>↵⇥<p>The second step that an attacker would undertake is to analyze the WSDL files and try to find potential weaknesses by sending messages matching the pattern described in the WSDL file. The attacker could run through all of the operations with different message request patterns until a breach is identified.</p>↵⇥</li>↵</ol>↵↵<p>Exploit</p>↵↵<ol>↵⇥<li>↵⇥<p>Once an attacker finds a potential weakness, they can craft malicious content to be sent to the system. For instance the attacker may try to submit special characters and observe how the system reacts to an invalid request. The message sent by the attacker may not be XML validated and cause unexpected behavior.</p>↵⇥</li>↵</ol>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>A client program connecting to a web service can read the WSDL to determine what functions are available on the server.</p>↵⇥</li>↵⇥<li>↵⇥<p>The target host exposes vulnerable functions within its WSDL interface.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>It is important to protect WSDL file or provide limited access to it.</p>↵↵<p>Review the functions exposed by the WSDL interface (especially if you have used a tool to generate it). Make sure that none of them is vulnerable to injection.</p>↵↵<p>Ensure the WSDL does not expose functions and APIs that were not intended to be exposed.</p>↵↵<p>Pay attention to the function naming convention (within the WSDL interface). Easy to guess function name may be an entry point for attack.</p>↵↵<p>Validate the received messages against the WSDL Schema. Incomplete solution.</p>↵",CAPEC
Probe iOS Screenshots,"<p>An adversary examines screenshot images created by iOS in an attempt to obtain sensitive information. These images are used by iOS to aid in the visual transition between open applications and improve the user&#39;s experience with a device. An application can be at risk even if it properly protects sensitive information when at rest. If the application displays sensitive information on the screen, then the potential exists for iOS to unintentionally record that information in an image file. An adversary can retrieve these images either by gaining access to the image files, or by physically obtaining the device and leveraging the multitasking switcher interface.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>This type of an attack requires physical access to a device to either excavate the image files (potentially by leveraging a Jailbreak) or view the screenshots through the multitasking switcher (by double tapping the home button on the device).</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>To mitigate this type of an attack, an application that may display sensitive information should clear the screen contents before a screenshot is taken. This can be accomplished by setting the key window&#39;s hidden property to YES. This code to hide the contents should be placed in both the applicationWillResignActive() and applicationDidEnterBackground() methods.</p>↵",CAPEC
Probe Application Memory,"<p>An adversary obtains unauthorized information due to insecure or incomplete data deletion in a multi-tenant environment. If a cloud provider fails to completely delete storage and data from former cloud tenants&#39; systems/resources, once these resources are allocated to new, potentially malicious tenants, the latter can probe the provided resources for sensitive information still there.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The cloud provider must not assuredly delete part or all of the sensitive data for which they are responsible.</p>↵↵⇥<p>The adversary must have the ability to interact with the system.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Cloud providers should completely delete data to render it irrecoverable and inaccessible from any layer and component of infrastructure resources.</p>↵↵<p>Deletion of data should be completed promptly when requested.</p>↵",CAPEC
Dump Password Hashes,"<p>An adversary obtains a collection of password hashes through the use of automated utilities designed specifically for gathering this type of information. Examples of credential dumpers include: pwdump7, Windows Credential Editor, Mimikatz, and gsecdump.</p>↵↵<p>Current credential dumpers access the LSASS process to obtain credentials through a process open and may inject code into that process. A malicious process may inject into a process that is known to frequently access LSASS beforehand to evade whitelisting. NTLM hash dumpers open the Security Accounts Manager (SAM) on the local file system (%SystemRoot%/system32/config/SAM) to access stored account password hashes. Some hash dumpers will open the local file system as a device and parse to the SAM table to avoid file access defenses. Others will make an in memory copy of the SAM table before reading hashes.</p>↵↵<p>Excavated credential data is often moved from the target system to some other adversary controlled system. Data found on a target system (e.g., hashes) might require extensive resources to be fully analyzed. Using these resources on the target system might enable a defender to detect the adversary. Additionally, proper analysis tools required might not be available on the target system.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>An adversary has the ability use or install the desired tools.</p>↵⇥</li>↵</ul>↵",CAPEC
Capture Credentials via Keylogger,"<p>An adversary deploys a keylogger in an effort to obtain credentials directly from a system&#39;s user. After capturing all the keystrokes made by a user, the adversary can analyze the data and determine which string are likely to be passwords or other credential related information.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The ability to install the keylogger, either in person or remote.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Strong physical security can help reduce the ability of an adversary to install a keylogger.</p>↵",CAPEC
Sniffing Network Traffic,"<p>An adversary monitors network traffic between nodes of a public or multicast network in an attempt to capture sensitive information. The adversary doesn&#39;t prevent reception or change content but simply observes and reads the traffic. The attacker might precipitate or indirectly influence the content of the observed transaction, but the attacker is never the intended recipient of the information.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Any target that transmits readable data over a public or multicast network could be attacked in this way.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Cryptographic techniques that render a data-stream unreadable can thwart this type of attack.</p>↵",CAPEC
Cellular Traffic Intercept,"<p>Cellular traffic for voice and data from mobile devices and retransmission devices can be intercepted via numerous methods. Malicious actors can deploy their own cellular tower equipment and intercept cellular traffic surreptitiously. Additionally, government agencies of adversaries and malicious actors can intercept cellular traffic via the telecommunications backbone over which mobile traffic is transmitted.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>None</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Encryption of all data packets emanating from the smartphone to a retransmission device via two encrypted tunnels with Suite B cryptography, all the way to the VPN gateway at the datacenter.</p>↵",CAPEC
Sniff Application Code,"<p>An adversary passively sniffs network communications and captures application code bound for an authorized client. Once obtained, they can use it as-is, or through reverse-engineering glean sensitive information or exploit the trust relationship between the client and server. Such code may belong to a dynamic update to the client, a patch being applied to a client component or any such interaction where the client is authorized to communicate with the server.</p>↵↵<p>&nbsp;Attack Steps</p>↵↵<p>Explore</p>↵↵<ol>↵⇥<li>↵⇥<p>The attacker sets up a sniffer in the path between the server and the client and watches the traffic.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>The attacker sets up a sniffer in the path between the server and the client.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>Exploit</p>↵↵<ol>↵⇥<li>↵⇥<p>Attacker knows that the computer/OS/application can request new applications to install, or it periodically checks for an available update. The attacker loads the sniffer set up during Explore phase, and extracts the application code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Attacker loads the sniffer to capture the application code bound during a dynamic update.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>The attacker proceeds to reverse engineer the captured code.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The attacker must have the ability to place himself in the communication path between the client and server.</p>↵⇥</li>↵⇥<li>↵⇥<p>The targeted application must receive some application code from the server; for example, dynamic updates, patches, applets or scripts.</p>↵⇥</li>↵⇥<li>↵⇥<p>The attacker must be able to employ a sniffer on the network without being detected.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Design: Encrypt all communication between the client and server.</p>↵↵<p>Implementation: Use SSL, SSH, SCP.</p>↵↵<p>Operation: Use &quot;ifconfig/ipconfig&quot; or other tools to detect the sniffer installed in the network.</p>↵",CAPEC
Intent Intercept,"<p>An adversary, through a previously installed malicious application, intercepts messages from a trusted Android-based application in an attempt to achieve a variety of different objectives including denial of service, information disclosure, and data injection. An implicit intent sent from a trusted application can be received by any application that has declared an appropriate intent filter. If the intent is not protected by a permission that the malicious application lacks, then the attacker can gain access to the data contained within the intent. Further, the intent can be either blocked from reaching the intended destination, or modified and potentially forwarded along.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>An adversary must be able install a purpose built malicious application onto the Android device and convince the user to execute it. The malicious application is used to intercept implicit intents.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>To mitigate this type of an attack, explicit intents should be used whenever sensitive data is being sent. An explicit intent is delivered to a specific application as declared within the intent, whereas the Android operating system determines who receives an implicit intent which could potentially be a malicious application. If an implicit intent must be used, then it should be assumed that the intent will be received by an unknown application and any response should be treated accordingly. Implicit intents should never be used for inter-application communication.</p>↵",CAPEC
Activity Hijack,"<p>An adversary, through a previously installed malicious application, intercepts an implicit intent sent to launch a trusted activity and instead launches a counterfeit activity in its place. The malicious activity is then used to mimic the trusted activity&#39;s user interface and convince the user to enter sensitive data as if they were interacting with the trusted activity.</p>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>To mitigate this type of an attack, explicit intents should be used whenever sensitive data is being sent. An explicit intent is delivered to a specific application as declared within the intent, whereas the Android operating system determines who receives an implicit intent which could potentially be a malicious application. If an implicit intent must be used, then it should be assumed that the intent will be received by an unknown application and any response should be treated accordingly. Implicit intents should never be used for inter-application communication.</p>↵",CAPEC
Explore for Predictable Temporary File Names,"<p>An attacker explores a target to identify the names and locations of predictable temporary files for the purpose of launching further attacks against the target. This involves analyzing naming conventions and storage locations of the temporary files created by a target application. If an attacker can predict the names of temporary files they can use this information to mount other attacks, such as information gathering and symlink attacks.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The targeted application must create names for temporary files using a predictable procedure, e.g. using sequentially increasing numbers.</p>↵⇥</li>↵⇥<li>↵⇥<p>The attacker must be able to see the names of the files the target is creating.</p>↵⇥</li>↵</ul>↵",CAPEC
Process Footprinting,<p>Adversaries may attempt to get information about running processes. An example Windows command that would display information about processes is &quot;tasklist&quot;.</p>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Identify programs that may be used to acquire process information and block them by using a software restriction policy or tools that restrict program execution by process whitelisting.</p>↵,CAPEC
Services Footprinting,<p>Adversaries may try to get information about registered services. Window commands that may obtain information about services are &quot;sc&quot; and &quot;net start&quot;.</p>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Identify programs that may be used to acquire service information and block them by using a software restriction policy or tools that restrict program execution by process whitelisting.</p>↵,CAPEC
Account Footprinting,<p>Adversaries may attempt to get a listing of all local or domain accounts and their permissions. Example Windows commands which can acquire this information are: &quot;net user&quot; and &quot;dsquery&quot;.</p>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Identify programs that may be used to acquire account information and block them by using a software restriction policy or tools that restrict program execution by process whitelisting.</p>↵,CAPEC
Group Permission Footprinting,<p>Adversaries may get a listing of all local groups and their permissions and members. An example Windows command which can list local groups is &quot;net localgroup&quot;.</p>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Identify programs (such as &quot;net&quot;) that may be used to enumerate local group permissions and block them by using a software restriction Policy or tools that restrict program execution by process whitelisting.</p>↵,CAPEC
Owner Footprinting,"<p>Adversaries may attempt to identify the primary users of the system. They may do this, for example, by reviewing logins or file modification times. An example Windows command that may accomplish this is &quot;dir /A ntuser.dat&quot;. Which will display the last modified time of a user&#39;s ntuser.dat file when run within the root folder of a user. This time is synonymous with the last time that user was logged in. Administrator permissions are required to view the home folder of other users.</p>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Ensure that proper permissions on files and folders are enacted to limit accessibility.</p>↵",CAPEC
Security Software Footprinting,<p>Adversaries may attempt to get a listing of security tools that are installed on the system and their configurations. This may include security related system features (such as a built-in firewall or anti-spyware) as well as third-party security software.</p>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Identify programs that may be used to acquire security tool information and block them by using a software restriction policy or tools that restrict program execution by process whitelisting.</p>↵,CAPEC
Reverse Engineer an Executable to Expose Assumed Hidden Functionality or Content,"<p>An attacker analyzes a binary file or executable for the purpose of discovering the structure, function, and possibly source-code of the file by using a variety of analysis techniques to effectively determine how the software functions and operates. This type of analysis is also referred to as Reverse Code Engineering, as techniques exist for extracting source code from an executable.</p>↵↵<p>Several techniques are often employed for this purpose, both black box and white box. The use of computer bus analyzers and packet sniffers allows the binary to be studied at a level of interactions with its computing environment, such as a host OS, inter-process communication, and/or network communication. This type of analysis falls into the &#39;black box&#39; category because it involves behavioral analysis of the software without reference to source code, object code, or protocol specifications.</p>↵",CAPEC
Read Sensitive Strings Within an Executable,"<p>An adversary engages in activities to discover any sensitive strings are present within the compiled code of an executable, such as literal ASCII strings within the file itself, or possibly strings hard-coded into particular routines that can be revealed by code refactoring methods including static and dynamic analysis.</p>↵↵<p>One specific example of a sensitive string is a hard-coded password. Typical examples of software with hard-coded passwords include server-side executables which may check for a hard-coded password or key during a user&#39;s authentication with the server. Hard-coded passwords can also be present in client-side executables which utilize the password or key when connecting to either a remote component, such as a database server, licensing server, or otherwise, or a processes on the same host that expects a key or password.</p>↵↵<p>When analyzing an executable the adversary may search for the presence of such strings by analyzing the byte-code of the file itself. Example utilities for revealing strings within a file include &#39;strings,&#39; &#39;grep,&#39; or other variants of these programs depending upon the type of operating system used. These programs can be used to dump any ASCII or UNICODE strings contained within a program. Strings can also be searched for using a hex editors by loading the binary or object code file and utilizing native search functions such as regular expressions.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Access to a binary or executable such that it can be analyzed by various utilities.</p>↵⇥</li>↵</ul>↵",CAPEC
Lifting Sensitive Data Embedded in Cache,"<p>An attacker examines a target application&#39;s cache for sensitive information. Many applications that communicate with remote entities or which perform intensive calculations utilize caches to improve efficiency. However, if the application computes or receives sensitive information and the cache is not appropriately protected, an attacker can browse the cache and retrieve this information. This can result in the disclosure of sensitive information.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The target application must store sensitive information in a cache.</p>↵⇥</li>↵⇥<li>↵⇥<p>The cache must be inadequately protected against attacker access.</p>↵⇥</li>↵</ul>↵",CAPEC
Retrieve Embedded Sensitive Data,"<p>An attacker examines a target system to find sensitive data that has been embedded within it. This information can reveal confidential contents, such as account numbers or individual keys/credentials that can be used as an intermediate step in a larger attack.</p>↵↵<p>&nbsp;Attack Steps</p>↵↵<p>Explore</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Identify Target</strong>: Attacker identifies client components to extract information from. These may be binary executables, class files, shared libraries (e.g., DLLs), configuration files, or other system files.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Binary file extraction. The attacker extracts binary files from zips, jars, wars, PDFs or other composite formats.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Package listing. The attacker uses a package manifest provided with the software installer, or the filesystem itself, to identify component files suitable for attack.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>Experiment</p>↵↵<ol>↵⇥<li>↵⇥<p><strong>Apply mining techniques</strong>: The attacker then uses a variety of techniques, such as sniffing, reverse-engineering, and cryptanalysis to extract the information of interest.</p>↵↵⇥<table border=""0"" style=""width:100%"">↵⇥⇥<tbody>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>API Profiling. The attacker monitors the software&#39;s use of registry keys or other operating system-provided storage locations that can contain sensitive information.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Execution in simulator. The attacker physically removes mass storage from the system and explores it using a simulator, external system, or other debugging harness.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Common decoding methods. The attacker applies methods to decode such encodings and compressions as Base64, unzip, unrar, RLE decoding, gzip decompression and so on.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥⇥<tr>↵⇥⇥⇥⇥<td style=""vertical-align:top"">↵⇥⇥⇥⇥<p>Common data typing. The attacker looks for common file signatures for well-known file types (JPEG, TIFF, ASN.1, LDIF, etc.). If the signatures match, he attempts decoding in that format.</p>↵⇥⇥⇥⇥</td>↵⇥⇥⇥</tr>↵⇥⇥</tbody>↵⇥</table>↵⇥</li>↵</ol>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>In order to feasibly execute this type of attack, some valuable data must be present in client software.</p>↵⇥</li>↵⇥<li>↵⇥<p>Additionally, this information must be unprotected, or protected in a flawed fashion, or through a mechanism that fails to resist reverse engineering, statistical, or other attack.</p>↵⇥</li>↵</ul>↵",CAPEC
Smudge Attack,<p>Attacks that reveal the password/passcode pattern on a touchscreen device by detecting oil smudges left behind by the user&rsquo;s fingers.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The attacker must have physical access to the device.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Strong physical security of the device.</p>↵,CAPEC
Analysis of Packet Timing and Sizes,"<p>An attacker may intercept and log encrypted transmissions for the purpose of analyzing metadata such as packet timing and sizes. Although the actual data may be encrypted, this metadata may reveal valuable information to an attacker. Note that this attack is applicable to VOIP data as well as application data, especially for interactive apps that require precise timing and low-latency (e.g. thin-clients).</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Use of untrusted communication paths enables an attacker to intercept and log communications, including metadata such as packet timing and sizes.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Distort packet sizes and timing at VPN layer by adding padding to normalize packet sizes and timing delays to reduce information leakage via timing.</p>↵",CAPEC
Electromagnetic Side-Channel Attack,"<p>In this attack scenario, the attacker passively monitors electromagnetic emanations that are produced by the targeted electronic device as an unintentional side-effect of its processing. From these emanations, the attacker derives information about the data that is being processed (e.g. the attacker can recover cryptographic keys by monitoring emanations associated with cryptographic processing).</p>↵↵<p>This style of attack requires proximal access to the device, however attacks have been demonstrated at public conferences that work at distances of up to 10-15 feet. There have not been any significant studies to determine the maximum practical distance for such attacks. Since the attack is passive, it is nearly impossible to detect and the targeted device will continue to operate as normal after a successful attack.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Proximal access to the device.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Utilize side-channel resistant implementations of all crypto algorithms.</p>↵↵<p>Strong physical security of all devices that contain secret key information. (even when devices are not in use)</p>↵",CAPEC
Compromising Emanations Attack,"<p>Compromising Emanations (CE) are defined as unintentional signals which an attacker may intercept and analyze to disclose the information processed by the targeted equipment. Commercial mobile devices and retransmission devices have displays, buttons, microchips, and radios that emit mechanical emissions in the form of sound or vibrations. Capturing these emissions can help an adversary understand what the device is doing.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>Proximal access to the device.</p>↵⇥</li>↵</ul>↵",CAPEC
Padding Oracle Crypto Attack,"<p>An adversary is able to efficiently decrypt data without knowing the decryption key if a target system leaks data on whether or not a padding error happened while decrypting the ciphertext. A target system that leaks this type of information becomes the padding oracle and an adversary is able to make use of that oracle to efficiently decrypt data without knowing the decryption key by issuing on average 128*b calls to the padding oracle (where b is the number of bytes in the ciphertext block). In addition to performing decryption, an adversary is also able to produce valid ciphertexts (i.e., perform encryption) by using the padding oracle, all without knowing the encryption key.</p>↵↵<p>Any cryptosystem can be vulnerable to padding oracle attacks if the encrypted messages are not authenticated to ensure their validity prior to decryption, and then the information about padding error is leaked to the adversary. This attack technique may be used, for instance, to break CAPTCHA systems or decrypt/modify state information stored in client side objects (e.g., hidden fields or cookies).</p>↵↵<p>This attack technique is a side-channel attack on the cryptosystem that uses a data leak from an improperly implemented decryption routine to completely subvert the cryptosystem. The one bit of information that tells the adversary whether a padding error during decryption has occurred, in whatever form it comes, is sufficient for the adversary to break the cryptosystem. That bit of information can come in a form of an explicit error message about a padding error, a returned blank page, or even the server taking longer to respond (a timing attack).</p>↵↵<p>This attack can be launched cross domain where an adversary is able to use cross-domain information leaks to get the bits of information from the padding oracle from a target system / service with which the victim is communicating. To do so an adversary sends a request containing ciphertext to the target system. Due to the browser&#39;s same origin policy, the adversary is not able to see the response directly, but can use cross-domain information leak techniques to still get the information needed (i.e., information on whether or not a padding error has occurred). For instance, this can be done using &quot;img&quot; tag plus the onerror()/onload() events. The adversary&#39;s JavaScript can make web browsers to load an image on the target site, and know if the image is loaded or not. This is 1-bit information needed for the padding oracle attack to work: if the image is loaded, then it is valid padding, otherwise it is not.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The decryption routine does not properly authenticate the message / does not verify its integrity prior to performing the decryption operation</p>↵⇥</li>↵⇥<li>↵⇥<p>The target system leaks data (in some way) on whether a padding error has occurred when attempting to decrypt the ciphertext.</p>↵⇥</li>↵⇥<li>↵⇥<p>The padding oracle remains available for enough time / for as many requests as needed for the adversary to decrypt the ciphertext.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Design: Use a message authentication code (MAC) or another mechanism to perform verification of message authenticity / integrity prior to decryption</p>↵↵<p>Implementation: Do not leak information back to the user as to any cryptography (e.g., padding) encountered during decryption.</p>↵",CAPEC
Cryptanalysis of Cellular Encryption,"<p>The use of cryptanalytic techniques to derive cryptographic keys or otherwise effectively defeat cellular encryption to reveal traffic content. Some cellular encryption algorithms such as A5/1 and A5/2 (specified for GSM use) are known to be vulnerable to such attacks and commercial tools are available to execute these attacks and decrypt mobile phone conversations in real-time. Newer encryption algorithms in use by UMTS and LTE are stronger and currently believed to be less vulnerable to these types of attacks. Note, however, that an attacker with a Cellular Rogue Base Station can force the use of weak cellular encryption even by newer mobile devices.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>None</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Use of hardened baseband firmware on retransmission device to detect and prevent the use of weak cellular encryption.</p>↵↵<p>Monitor cellular RF interface to detect the usage of weaker-than-expected cellular encryption.</p>↵",CAPEC
IP ID Sequencing Probe,"<p>This OS fingerprinting probe analyzes the IP &#39;ID&#39; field sequence number generation algorithm of a remote host. Operating systems generate IP &#39;ID&#39; numbers differently, allowing an attacker to identify the operating system of the host by examining how is assigns ID numbers when generating response packets. RFC 791 does not specify how ID numbers are chosen or their ranges, so ID sequence generation differs from implementation to implementation. There are two kinds of IP &#39;ID&#39; sequence number analysis:</p>↵↵<ul>↵⇥<li>1. IP &#39;ID&#39; Sequencing: Analyzing the IP &#39;ID&#39; sequence generation algorithm for one protocol used by a host.</li>↵⇥<li>2. Shared IP &#39;ID&#39; Sequencing: Analyzing the packet ordering via IP &#39;ID&#39; values spanning multiple protocols, such as between ICMP and TCP.</li>↵</ul>↵",CAPEC
IP 'ID' Echoed Byte-Order Probe,<p>This OS fingerprinting probe tests to determine if the remote host echoes back the IP &#39;ID&#39; value from the probe packet. An attacker sends a UDP datagram with an arbitrary IP &#39;ID&#39; value to a closed port on the remote host to observe the manner in which this bit is echoed back in the ICMP error message. The identification field (ID) is typically utilized for reassembling a fragmented packet. Some operating systems or router firmware reverse the bit order of the ID field when echoing the IP Header portion of the original datagram within an ICMP error message.</p>↵,CAPEC
IP (DF) 'Don't Fragment Bit' Echoing Probe,<p>This OS fingerprinting probe tests to determine if the remote host echoes back the IP &#39;DF&#39; (Don&#39;t Fragment) bit in a response packet. An attacker sends a UDP datagram with the DF bit set to a closed port on the remote host to observe whether the &#39;DF&#39; bit is set in the response packet. Some operating systems will echo the bit in the ICMP error message while others will zero out the bit in the response packet.</p>↵,CAPEC
TCP Timestamp Probe,"<p>This OS fingerprinting probe examines the remote server&#39;s implementation of TCP timestamps. Not all operating systems implement timestamps within the TCP header, but when timestamps are used then this provides the attacker with a means to guess the operating system of the target. The attacker begins by probing any active TCP service in order to get response which contains a TCP timestamp. Different Operating systems update the timestamp value using different intervals. This type of analysis is most accurate when multiple timestamp responses are received and then analyzed. TCP timestamps can be found in the TCP Options field of the TCP header.</p>↵↵<ul>↵⇥<li>1. The adversary sends a probe packet to the remote host to identify if timestamps are present.</li>↵⇥<li>2. If the remote host is using timestamp, the adversary sends several requests and records the timestamp values.</li>↵⇥<li>3. The adversary analyzes the timestamp values and determines an average increments per second in the timestamps for the target.</li>↵⇥<li>3. The adversary compares this result to a database of known TCP timestamp increments for a possible match.</li>↵</ul>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The ability to monitor and interact with network communications.</p>↵↵⇥<p>Access to at least one host, and the privileges to interface with the network interface card.</p>↵↵⇥<p>The target OS must support the TCP timestamp option in order to obtain a fingerprint.</p>↵⇥</li>↵</ul>↵",CAPEC
Inject Unexpected Items,"<p>Attack patterns within this category focus on the ability to control or disrupt the behavior of an target either through crafted data submitted via an interface for data input, or the installation and execution of malicious code on the target system. The former happens when an adversary adds material to their input that is interpreted by the application causing the targeted application to perform steps unintended by the application manager or causing the application to enter an unstable state. Attacks of this type differ from Data Structure Attacks in that the latter attacks subvert the underlying structures that hold user-provided data, either pre-empting interpretation of the input (in the case of Buffer Overflows) or resulting in values that the targeted application is unable to handle correctly (in the case of Integer Overflows). In Injection attacks, the input is interpreted by the application, but the attacker has included instructions to the interpreting functions that the target application then follows.</p>↵",CAPEC
Parameter Injection,"<p>An adversary exploits weaknesses in input validation by manipulating the content of request parameters for the purpose of undermining the security of the target. Some parameter encodings use text characters as separators. For example, parameters in a HTTP GET message are encoded as name-value pairs separated by an ampersand (&amp;). If an attacker can supply text strings that are used to fill in these parameters, then they can inject special characters used in the encoding scheme to add or modify parameters. For example, if user input is fed directly into an HTTP GET request and the user provides the value &quot;myInput&amp;new_param=myValue&quot;, then the input parameter is set to myInput, but a new parameter (new_param) is also added with a value of myValue. This can significantly change the meaning of the query that is processed by the server. Any encoding scheme where parameters are identified and separated by text characters is potentially vulnerable to this attack - the HTTP GET encoding used above is just one example.</p>↵↵<p>&nbsp;Attack Prerequisites</p>↵↵<ul>↵⇥<li>↵⇥<p>The target application must use a parameter encoding where separators and parameter identifiers are expressed in regular text.</p>↵⇥</li>↵⇥<li>↵⇥<p>The target application must accept a string as user input, fail to sanitize characters that have a special meaning in the parameter encoding, and insert the user-supplied string in an encoding which is then processed.</p>↵⇥</li>↵</ul>↵↵<p>&nbsp;Solutions and Mitigations</p>↵↵<p>Implement an audit log written to a separate host. In the event of a compromise, the audit log may be able to provide evidence and details of the compromise.</p>↵↵<p>Treat all user input as untrusted data that must be validated before use.</p>↵",CAPEC